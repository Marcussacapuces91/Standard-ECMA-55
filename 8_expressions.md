# Expressions
## General Description

Expressions shall be either numeric-expressions or string- expressions.

Numeric-expressions may be constructed from variables, constants, and function references using the operations of addition, subtraction, multiplication, division and involution.

String-expressions are composed of either a string-variable or a string-constant.

## Syntax

1. expression = numeric-expression / string-expression
2. numeric-expression = sign? term (sign term)*
3. term = factor (multiplier factor)*
4. factor = primary (circumflex-accent primary)*
5. multiplier = asterisk / solidus
6. primary = numeric-variable / numeric-rep / numeric-function-ref / left-parenthesis numeric-expression
7. numeric-function-ref = numeric-function-name argument-list?
8. numeric-function-name = numeric-defined-function / numeric-supplied-function
9. argument-list = left-parenthesis argument right-parenthesis
10. argument = numeric-expression
11. string-expression = string-variable / string-constant

## Examples

    3*X - Y^2      A(1)+A(2)+A(3)    2^(-X)
    -X/Y           SQR(X~2+Y^2)
    
## Semantics

The formation and evaluation of numeric-expressions follows the normal algebraic rules. The symbols circumflex-accent, asteris , solidus, plus-sign and minus-sign represent the operations of involution, multiplication, division, addition and subtraction, respectively. Unless parentheses dictate otherwise, involutions are performed first, then multiplications and divisions, and finally additions and subtractions. In the absence of parentheÂ¬ ses, operations of the same precedence are associated to the
left.

`A-B-C` is interpreted as `(A-B)-C`, `A^B^C` as `(A^B)^C`, `A/B/C` as `(A/B)/C` and `-A^B` as `-(A^B)`.

If an underflow occurs in the evaluation of a numeric expression then the value generated by the operation which resulted in t e underflow shall be replaced by zero.

`0^0` is defined to be `1`, as in ordinary mathematical usage.

When the order of evaluation of an expression is not constrained by the use of parentheses, and if the mathematical use of operators is associative, commutative, or both, then full use of thes< properties may be made in order to revise the order of evaluation of the expression.

In a function reference, the number of arguments supplied shall be equal to the number of parameters required by the definition of the function.

A function reference is a notation for the invocation of a predefined algorithm, into which the argument value, if any, is substituted for the parameter (see 9 and 10) which is used in the function definition. All functions referenced in an expression shall either be implementation-supplied or be defined in a def-statement. The result of the evaluation of the function, achieved by the execution of the defining algorithm, is a scalar numeric value which replaces the function reference in the expression.

## Exceptions

- Evaluation of an expression results in division by zero (nonfatal, the recommended recovery procedure is to supply machine infinity with the sign of the numerator and continue).
- Evaluation of an expression results in an overflow (nonfatal, the recommended recovery procedure is to supply machine infinity with the algebraically correct sign and continue).
- Evaluation of the operation of involution results in a negative number being raised to a non-integral power (fatal).
- Evaluation of the operation of involution results in zero being raised to a negative value (nonfatal, the recommended recovery procedure is to supply positive machine infinity and continue).
  
## Remarks

The accuracy with which the evaluation of an expression takes place will vary from implementation to implementation. While no minimum accuracy is specified for the evaluation of numeric- expressions, it is recommended that implementations maintain at least six significant decimal digits of precision.

The method of evaluation of the operation of involution may depend upon whether or not the exponent is an integer. If it is, then the indicated number of multiplications may be performed; if it is not, then the expression may be evaluated using the LOG and EXP functions (see 9).

It is recommended that implementations report underflow as an exception and continue.
